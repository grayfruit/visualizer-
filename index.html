<!DOCTYPE html>
<html>
<head>
    <style>
        body { 
            margin: 0;
            overflow: hidden;
            background: #0a0a0a;
        }
        canvas {
            width: 100vw;
            height: 100vh;
        }
        #startBtn {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            font-size: 16px;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.8);
            cursor: pointer;
            border-radius: 25px;
            font-family: monospace;
            transition: all 0.4s ease;
            letter-spacing: 2px;
        }
        #startBtn:hover {
            background: rgba(255,255,255,0.05);
            border-color: rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>
    <button id="startBtn">initialize</button>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        
        let audioCtx;
        let analyser;
        let dataArray;
        let isPlaying = false;
        let time = 0;
        let points = [];
        
        // Kolory w stylu mrocznym/minimalistycznym
        const colors = [
            { r: 20, g: 20, b: 25 },    // Ciemny granatowy
            { r: 40, g: 35, b: 45 },    // Ciemny fioletowy
            { r: 25, g: 30, b: 35 }     // Ciemny niebieskoszary
        ];

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initPoints();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Inicjalizacja punktów kontrolnych dla krzywych
        function initPoints() {
            points = [];
            const rows = 5;
            const cols = 5;
            const cellWidth = canvas.width / (cols - 1);
            const cellHeight = canvas.height / (rows - 1);

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    points.push({
                        x: x * cellWidth,
                        y: y * cellHeight,
                        baseX: x * cellWidth,
                        baseY: y * cellHeight,
                        angle: Math.random() * Math.PI * 2
                    });
                }
            }
        }

        startBtn.addEventListener('click', async () => {
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 1024;
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const source = audioCtx.createMediaStreamSource(stream);
                    source.connect(analyser);
                    
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                    startBtn.style.display = 'none';
                    isPlaying = true;
                    animate();
                } catch (err) {
                    console.error('Error:', err);
                    alert('Please allow microphone access for visualization');
                }
            }
        });

        function lerpColor(color1, color2, factor) {
            return {
                r: Math.round(color1.r + (color2.r - color1.r) * factor),
                g: Math.round(color1.g + (color2.g - color1.g) * factor),
                b: Math.round(color1.b + (color2.b - color1.b) * factor)
            };
        }

        function updatePoints(frequencyData) {
            const bassValue = frequencyData.slice(0, 10).reduce((a, b) => a + b, 0) / 2000;
            const midValue = frequencyData.slice(100, 200).reduce((a, b) => a + b, 0) / 10000;
            
            points.forEach((point, i) => {
                point.angle += 0.02 + bassValue * 0.01;
                
                const distanceFromCenter = Math.hypot(
                    point.baseX - canvas.width/2,
                    point.baseY - canvas.height/2
                ) / Math.hypot(canvas.width/2, canvas.height/2);
                
                const amplitude = 50 * (1 - distanceFromCenter) * (1 + bassValue * 2);
                const frequency = 0.002 + midValue * 0.001;
                
                point.x = point.baseX + Math.cos(point.angle) * amplitude;
                point.y = point.baseY + Math.sin(point.angle * 1.5) * amplitude;
            });
        }

        function drawLiquidShape(frequencyData) {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Rysowanie płynnych gradientów
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const index = row * 5 + col;
                    const p0 = points[index];
                    const p1 = points[index + 1];
                    const p2 = points[index + 5];
                    const p3 = points[index + 6];

                    // Tworzenie gradientu dla każdego segmentu
                    const gradient = ctx.createLinearGradient(
                        p0.x, p0.y,
                        p3.x, p3.y
                    );

                    const freqIndex = (row * 4 + col) * 8;
                    const intensity = frequencyData.slice(freqIndex, freqIndex + 8).reduce((a, b) => a + b, 0) / 2040;
                    
                    const color1 = colors[row % colors.length];
                    const color2 = colors[(row + 1) % colors.length];
                    const mixedColor = lerpColor(color1, color2, intensity);

                    gradient.addColorStop(0, `rgba(${mixedColor.r}, ${mixedColor.g}, ${mixedColor.b}, 0.4)`);
                    gradient.addColorStop(1, `rgba(${color2.r}, ${color2.g}, ${color2.b}, 0.1)`);

                    ctx.beginPath();
                    ctx.moveTo(p0.x, p0.y);
                    
                    // Kontrolne punkty dla krzywej Beziera
                    const cpX1 = p0.x + (p3.x - p0.x) / 3;
                    const cpY1 = p0.y + (p3.y - p0.y) / 3;
                    const cpX2 = p0.x + 2 * (p3.x - p0.x) / 3;
                    const cpY2 = p0.y + 2 * (p3.y - p0.y) / 3;
                    
                    ctx.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, p3.x, p3.y);
                    ctx.lineTo(p2.x, p2.y);
                    
                    const cpX3 = p2.x + (p1.x - p2.x) / 3;
                    const cpY3 = p2.y + (p1.y - p2.y) / 3;
                    const cpX4 = p2.x + 2 * (p1.x - p2.x) / 3;
                    const cpY4 = p2.y + 2 * (p1.y - p2.y) / 3;
                    
                    ctx.bezierCurveTo(cpX3, cpY3, cpX4, cpY4, p1.x, p1.y);
                    ctx.closePath();
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }
            }
        }

        function animate() {
            if (!isPlaying) return;
            
            analyser.getByteFrequencyData(dataArray);
            updatePoints(dataArray);
            drawLiquidShape(dataArray);
            time += 0.01;
            
            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>
