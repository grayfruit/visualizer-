<!DOCTYPE html>
<html>
<head>
    <style>
        body { 
            margin: 0;
            overflow: hidden;
            background: #1a1a2e;
        }
        canvas {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }
        #startBtn {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            font-size: 16px;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.5);
            color: rgba(255,255,255,0.9);
            cursor: pointer;
            border-radius: 3px;
            font-family: monospace;
            transition: all 0.4s ease;
            letter-spacing: 2px;
            z-index: 100;
        }
        #startBtn:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.8);
        }
    </style>
</head>
<body>
    <button id="startBtn">initialize</button>
    <canvas id="mainCanvas"></canvas>
    <canvas id="glitchCanvas"></canvas>
    <script>
        const mainCanvas = document.getElementById('mainCanvas');
        const mainCtx = mainCanvas.getContext('2d');
        const glitchCanvas = document.getElementById('glitchCanvas');
        const glitchCtx = glitchCanvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        
        let audioCtx;
        let analyser;
        let dataArray;
        let isPlaying = false;

        function resizeCanvas() {
            mainCanvas.width = window.innerWidth;
            mainCanvas.height = window.innerHeight;
            glitchCanvas.width = window.innerWidth;
            glitchCanvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        startBtn.addEventListener('click', async () => {
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 1024;
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const source = audioCtx.createMediaStreamSource(stream);
                    source.connect(analyser);
                    
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                    startBtn.style.display = 'none';
                    isPlaying = true;
                    animate();
                } catch (err) {
                    console.error('Error:', err);
                    alert('Please allow microphone access for visualization');
                }
            }
        });

        function createGlitchEffect(ctx, intensity) {
            const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
            const data = imageData.data;
            
            // RGB Split
            const splitAmount = Math.floor(intensity * 20);
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = ctx.canvas.width;
            tempCanvas.height = ctx.canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Red channel
            tempCtx.drawImage(ctx.canvas, -splitAmount, 0);
            const redData = tempCtx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height).data;
            
            // Blue channel
            tempCtx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            tempCtx.drawImage(ctx.canvas, splitAmount, 0);
            const blueData = tempCtx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height).data;

            // Combine channels with glitch
            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() < intensity * 0.1) {
                    data[i] = data[i + 4] || data[i]; // Red glitch
                    data[i + 2] = data[i + 6] || data[i + 2]; // Blue glitch
                }
                
                // RGB Split
                data[i] = redData[i]; // Red
                data[i + 2] = blueData[i + 2]; // Blue

                // Random noise
                if (Math.random() < intensity * 0.05) {
                    data[i] = data[i + 1] = data[i + 2] = Math.random() * 255;
                }

                // Scan lines
                if ((Math.floor(i / 4 / ctx.canvas.width) % 2) === 0 && Math.random() < intensity * 0.2) {
                    data[i] = data[i + 1] = data[i + 2] = (data[i] + data[i + 1] + data[i + 2]) / 3;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Horizontal glitch blocks
            if (Math.random() < intensity * 0.5) {
                const blockHeight = Math.random() * 50;
                const blockY = Math.random() * ctx.canvas.height;
                const blockShift = (Math.random() - 0.5) * intensity * 100;
                
                const blockData = ctx.getImageData(0, blockY, ctx.canvas.width, blockHeight);
                ctx.putImageData(blockData, blockShift, blockY);
            }
        }

        function drawBaseShape(ctx, intensity) {
            const centerX = ctx.canvas.width / 2;
            const centerY = ctx.canvas.height / 2;
            const maxRadius = Math.min(ctx.canvas.width, ctx.canvas.height) * 0.4;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // Główny kształt
            for (let i = 0; i < 3; i++) {
                const angle = intensity * Math.PI * 2;
                const radius = maxRadius * (1 + intensity * 0.5);
                
                ctx.beginPath();
                for (let a = 0; a < Math.PI * 2; a += 0.1) {
                    const r = radius * (1 + Math.sin(a * 3 + angle) * 0.2 * intensity);
                    const x = centerX + Math.cos(a) * r;
                    const y = centerY + Math.sin(a) * r;
                    
                    if (a === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                
                const hue = (200 + i * 120 + intensity * 60) % 360;
                ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${0.5 - i * 0.1})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function animate() {
            if (!isPlaying) return;
            
            analyser.getByteFrequencyData(dataArray);
            
            // Oblicz intensywność dla różnych zakresów częstotliwości
            const bassIntensity = dataArray.slice(0, 10).reduce((a, b) => a + b, 0) / 2000;
            const midIntensity = dataArray.slice(100, 200).reduce((a, b) => a + b, 0) / 4000;
            const highIntensity = dataArray.slice(200, 300).reduce((a, b) => a + b, 0) / 6000;
            
            // Rysuj podstawowy kształt
            drawBaseShape(mainCtx, bassIntensity);
            
            // Kopiuj do kanwy glitch
            glitchCtx.clearRect(0, 0, glitchCanvas.width, glitchCanvas.height);
            glitchCtx.drawImage(mainCanvas, 0, 0);
            
            // Aplikuj efekty glitch
            const totalIntensity = (bassIntensity + midIntensity + highIntensity) / 3;
            createGlitchEffect(glitchCtx, totalIntensity);
            
            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>
